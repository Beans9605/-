# React 

## DOM ? Virtual DOM ?
DOM은 MDN(Mozilla)에서는 DOM을 "HTML, XML document와 상호작용하고 표현하는 API이다, DOM은 브라우저에서 로드되며, 노드 트리로 표현하는 document 모델이다."라고 코멘트 하고있다.


## Tree Shaking
#개발이슈 #javascript #tech #speed #improvement

### 개요
현 시점의 웹 애플리케이션들은 굉장히 크고, 대부분 자바스크립트로 만들어져있음, 18년 중순 HTTP Archive가 보여준 모바일 장치에서 자바스크립트의 평균 전송 크기는 350KB, 하지만 단순한 전송 크기일 뿐, 실제로 전송크디는 300KB로 압축돼서 오지만 파싱되고 컴파일 및 실행하면 900KB까지 증가 할 수 있다.
자바스크립트는 수행하는데 비용이 많이 듦, 따라서 자바스크립의 성능 개선을 위한 기술이 여러가지 있다.

코드 스플리팅(https://webpack.js.org/guides/code-splitting/), 자바스크립트 청크로 애플리케이션을 분할하고, 청크를 필요로 하는 애플리케이션의 경로에만 이 청크를 배분하여 성능을 개선하는 기술이 있다.

하지만 이 코드 스플리팅이 근본적인 원인을 해결해주진 않는다. 사용되지 않는 코드를 포함한 무거운 자바스크립트 애플리케이션의 일반적인 문제를 해결하기 위해서는 **트리 쉐이킹**이라는 기술을 사용해야한다.

### 본문
#### 트리 쉐이킹이란?
트리 쉐이킹은 사용하지 않는 코드를 제거하는 방식, (이 용어는 [[#Rollup]]에 의해 부상함)
트리 쉐이킹이라는 용어는 애플리케이션의 멘탈 모델(mental model)과 디펜던시 트리 구조에서 유래됐음. 트리 내 각 노드들은 앱을 위해 특징적인 기능들을 제공하는 디펜던시들을 나타냄,

``` javascript

import arrayUtils from "array-utils"

```

현 앱에서는 이러한 디펜던시들을 import (정적구문)으로 가져올 수 있음.
이렇게 모든 기능에 대한 디펜던시를 걸린 유틸 전체를 불러오게된다면, 나의 array-utils가 가진 모든 기능에 대한 코드를 불러오게 됨. (사용하지 않는 것을 포함한)

``` javascript

import { unique, implode, explode } from "array-utils"

```

거의 모든 다른 언어에서도 코드를 작성할때 권장하는 방식으로, 내가 사용할 라이브러리 코드만 따로 불러와서 사용하는 방식이다.
개발 빌드에서는 어떤 것도 설정하지 않았기 때문에 이렇게 작성하여도 import 된것과 상관 없이 전체 모듈을 불러옴
허나 프로덕션 빌들에서는 명시적으로 import 되지 않은 ES6 모듈로부터 export를 shake 하기 위해서 webpack을 설정하고 빌드 결과물 크기를 더 작게 할 수 있음.

## Rollup
### 개요
롤업은 웹팩과 마찬가지로 자바스크립트 번들러의 종류
- 자바스크립트는 실제로 불러와서 컴파일을 하려면 여러 개의 자바스크립트 파일을 하나로 만들어서 사용해야함, 이 작업을 사람이 일일히 할 수 없으므로 자바스크립트 파일들의 의존성과 연결성을 충족하는 하나의 파일로 만들기 위해서 웹팩이라는 자바스크립트 번들러가 등장함.
- react 역시 webpack으로 많은 js, jsx 파일들을 하나의 js 파일로 빌드하여 실제 동작하게끔 함.
- 수 많은 라이브러리를 연결하는 일은 굉장히 괴로운 것
롤업은 웹팩과 다르게 빌드 결과물을 ES6 모듈 형태로 만들 수 있음, ES6 모듈로 빌드가 가능하다는 것은 사용하는 쪽에서 라이브러리 전체를 불러오는 게 아니라 필요한 부분만 콕 집어서 가져올 수 있다는 특징 존재,


# React Hooks

Hooks는 리액트 16.8 에 새로 도입된 기능
함수형 컴포넌트에서도 상태 관리를 할 수 있는 state, 렌더링 직후 작업을 설정하는 effect 기능들을 통해 작업 다양성 추구

## useState

비동기적 상태 관리에서 동기 상태 관리와 충돌하는 경우
```JSX
function App() {

	const [count, setCount] = useState(0)

	const plusCount = () => {
		setCount(count + 1)
	}

	const asyncPlusCount = () => {
		setTimeout(() => {
			setCount((prev) => prev+1)
		}, [2000])
	}

	<div>
		{ count }
	</div>
}
```

state는 말 그대로 상태이기 때문에, setCount를 할때 참조되는 값이 count의 현재 상태가 아닌 함수를 실행할때 그때의 값을 참조하여 사용되기 때문에, setCount를 할 때의 시점의 state value를 바로 가져와 쓸 수 있는 내부 함수를 통해서 변경해야함.


## MUI with Tailwind ([[Tailwind]] N [[javascript N Typescript]])

### 개요

### 적용 사례

### 적용 방법

### 장단점

## PWA
### 개요

### 적용 사례

### 적용 방법

### 장단점
